# Notion API 2025-09-03 Upgrade

**Date:** 2026-01-15
**Status:** Proposal

## Problem

The application currently uses an older version of the Notion API. Notion API version 2025-09-03 introduces breaking changes around multi-source databases that require migration to continue functioning correctly.

## Goal

Upgrade to Notion API version 2025-09-03 to:
- Support multi-source databases (databases as containers with multiple data sources)
- Use the new `/v1/data_sources` endpoints for database operations
- Maintain compatibility with future Notion API changes
- Prevent disruption when Notion deprecates older API versions

## Key Changes in 2025-09-03

### 1. Multi-Source Database Model

Notion now separates "databases" (containers) from "data sources" (tables):

**Before (old model):**
```
Database = Single table of pages
```

**After (new model):**
```
Database (container)
  └── Data Source 1 (table)
  └── Data Source 2 (table)
  └── Data Source N (table)
```

### 2. API Endpoint Reorganization

| Operation | Old Endpoint | New Endpoint |
|-----------|-------------|--------------|
| Query database pages | `POST /v1/databases/{database_id}/query` | `POST /v1/data_sources/{data_source_id}/query` |
| Create page in database | `POST /v1/pages` (with `parent.database_id`) | `POST /v1/pages` (with `parent.data_source_id`) |
| Retrieve database | `GET /v1/databases/{database_id}` | `GET /v1/data_sources/{data_source_id}` |
| Update database properties | `PATCH /v1/databases/{database_id}` | `PATCH /v1/data_sources/{data_source_id}` |
| Database container info | N/A | `GET /v1/databases/{database_id}` |

### 3. Parent Object Changes

When creating or querying pages, the parent object now uses `data_source_id`:

**Before:**
```json
{
  "parent": {
    "type": "database_id",
    "database_id": "abc123"
  }
}
```

**After:**
```json
{
  "parent": {
    "type": "data_source_id",
    "data_source_id": "ds_abc123"
  }
}
```

### 4. Relation Property Changes

Database relations now require `data_source_id`:

**Before:**
```json
{
  "relation": {
    "type": "dual_property",
    "dual_property": {
      "synced_property_name": "Related",
      "database_id": "xyz789"
    }
  }
}
```

**After:**
```json
{
  "relation": {
    "type": "dual_property",
    "dual_property": {
      "synced_property_name": "Related",
      "data_source_id": "ds_xyz789"
    }
  }
}
```

## Migration Strategy

### Phase 1: Discovery

Add a discovery step to fetch and store `data_source_id` for each database:

1. When encountering a `database_id`, call `GET /v1/databases/{database_id}`
2. Extract the default data source: `database.data_sources[0].id`
3. Store the mapping: `database_id -> data_source_id`
4. Use `data_source_id` for all subsequent operations

### Phase 2: Code Updates

Update all database-related code to:

1. **Query operations**: Use `/v1/data_sources/{data_source_id}/query`
2. **Page creation**: Use `parent.data_source_id` instead of `parent.database_id`
3. **Property updates**: Use `/v1/data_sources/{data_source_id}`
4. **Relations**: Replace `database_id` with `data_source_id` in relation properties

### Phase 3: API Version Header

Update the API version header in all requests:

```go
req.Header.Set("Notion-Version", "2025-09-03")
```

## Implementation Details

### Data Source Resolution

For backwards compatibility during migration, maintain a mapping:

```go
type DataSourceMapping struct {
    DatabaseID   string
    DataSourceID string
    CachedAt     time.Time
}
```

**Resolution logic:**
```go
func (c *Client) resolveDataSourceID(ctx context.Context, databaseID string) (string, error) {
    // Check cache first
    if cached, ok := c.dataSourceCache[databaseID]; ok {
        return cached.DataSourceID, nil
    }

    // Fetch database container
    db, err := c.getDatabase(ctx, databaseID)
    if err != nil {
        return "", err
    }

    // Get default data source (first in list)
    if len(db.DataSources) == 0 {
        return "", fmt.Errorf("database %s has no data sources", databaseID)
    }

    dataSourceID := db.DataSources[0].ID

    // Cache the mapping
    c.dataSourceCache[databaseID] = DataSourceMapping{
        DatabaseID:   databaseID,
        DataSourceID: dataSourceID,
        CachedAt:     time.Now(),
    }

    return dataSourceID, nil
}
```

### Registry Updates

Update registry to store both `database_id` and `data_source_id`:

```json
{
  "id": "page-abc123",
  "parent_database_id": "db-xyz789",
  "parent_data_source_id": "ds-xyz789",
  "file_path": "teamspace/database-page.md",
  "last_edited": "2026-01-15T10:30:00Z"
}
```

### Frontmatter Updates

Add `data_source_id` to page frontmatter when parent is a database:

```markdown
---
notion_id: abc123def456789
notion_parent_id: xyz789parent
notion_data_source_id: ds-xyz789data
last_edited: 2026-01-15T10:30:00Z
---
```

## Testing Strategy

1. **Unit tests**: Mock API responses with new data source format
2. **Integration tests**: Test against real Notion workspace with multi-source databases
3. **Backwards compatibility**: Verify old registry files still work
4. **Migration test**: Test upgrade from current version to 2025-09-03

## Rollout Plan

1. Add feature flag: `NOTION_API_VERSION_2025_09_03`
2. Implement data source resolution with caching
3. Update all API calls behind feature flag
4. Test with subset of users
5. Enable by default
6. Remove feature flag after stable release

## References

- [Upgrading to Version 2025-09-03](https://developers.notion.com/docs/upgrade-guide-2025-09-03)
- [Version 2025-09-03 FAQs](https://developers.notion.com/docs/upgrade-faqs-2025-09-03)
- [Changes by version](https://developers.notion.com/reference/changes-by-version)
